## **I - Introduction to Python**

### 1. **What is Python?**

Python is a high-level, interpreted programming language that is known for its simplicity and readability. It is widely used for a variety of tasks, including web development, data science, artificial intelligence, automation, and scripting. Python is popular among both beginners and experienced developers due to its clear syntax and large ecosystem of libraries and frameworks.

**Key Characteristics:**
- **High-level:**  Python allows developers to write code that is closer to human language than machine language, which makes it easier to understand and use. The language handles many of the complexities of low-level operations, like memory allocation, so developers can focus more on solving problems rather than managing hardware resources.
- **Interpreted:** Python code is executed line-by-line by an interpreter, which makes it easy to test and debug.
- **Extensive Libraries:** Python boasts a huge selection of built-in and third-party libraries for tasks like web scraping, data visualization, and machine learning.
- **Community Support:** Python has an active and helpful community, making it easy to find tutorials, documentation, and solutions to problems.

### 2. **Python Installation**

Python can be easily installed on various operating systems. The **Conda** setup covered in the previous tutorial already includes Python as part of the installation. If you want to install Python manually, you can download it from the [official website](https://www.python.org/) and follow the installation instructions based on your operating system.

If you're using Conda, Python will be pre-installed, and you can confirm this by running the following command in the terminal:

```bash
$ python --version
```

This will display the installed version of Python. You can also use `python3` in some environments, especially if multiple versions of Python are installed.

### 3. **Running Python Code**

Python code can be executed in several ways:

- **Interactive Mode**:

    You can run Python interactively directly from the terminal by simply typing `python` (or `python3`). This will launch the Python shell where you can execute code line by line.
    ```bash
    $ python
    >>> print("Hello, World!")
    Hello, World!
    >>> quit()  # Exits the interactive mode
    ```
    In this mode, you can quickly test small snippets of code.

- **Scripts**:

    Python scripts are saved with the `.py` extension and can be run from the command line.
    ```bash
    $ python script.py
    ```
    You can add a "shebang" (`#!/usr/bin/env python3`) at the top of your Python file. This enables the script to be executed directly from the command line without needing to explicitly invoke the Python interpreter.
    ```bash
    $ ./script.py
    ```
    ⚠️ You may need to ensure the script has the correct permissions:
    ```bash
    $ chmod +x script.py
    ```

- **Notebooks**:

    For a more interactive and flexible environment, Jupyter Notebooks allow you to run Python code in interactive cells, which can also contain code, text (written in Markdown), and rich media outputs (such as interactive plots or images).
    
    When executing Python code in a notebook, the cell will process the code and display the result directly below the input. Jupyter uses JavaScript to manage interactions between the notebook interface and Python, creating a hybrid environment ideal for experimentation, data analysis, and documentation.


## II - Basic Syntax

### 1. **Variables**

Variables are used to store values that you can refer to later in your program. You can *assign* a value to a variable by using the `=` operator.
A variable that has been assigned a value is considered *declared*.
```python
age = 25
```
The variable `age` is now assigned the value `25`.
```python
name = "Alice"
```
The variable `name` is now assigned the value `Alice`.

⚠️ Here the quotes (`"`) are necessary, otherwise python would think `Alice` is the name of another, previously-declared, variable from which we want to assign the value to `age`.
Numbers (such as `25`) cannot be used as variables, so they do not need to be surounded by quotes `"`.

You can assign a new value to a variable at any time:
```python
age = 30
```
The variable `age` is now assigned the value `30`.

Variable manipulation is at the core of programming, forming the foundation for more complex logic, functionality, and flexibility.

### 2. **Comments**

Comments are used to annotate your code with explanations or notes. They are ignored by the Python interpreter and are essential for making your code more understandable.

- **Single-line comments**: You can add a comment by starting the line with a `#`.

```python
# This is a comment
x = 10  # This is an inline comment
```

- **Multi-line comments**: Although Python doesn't have a specific syntax for multi-line comments, you can use triple quotes (`""" """` or `''' '''`) to create block comments. These are often used for docstrings (documentation strings), but can also be used as comments.

```python
"""
This is a multi-line comment.
It can span several lines.
"""
x = 20
```

### 3. **Using Functions**

Functions are a key part of programming that allow you to run specific tasks by calling pre-defined blocks of code. By using functions, you can simplify your code and perform advanced operations. Here are some basic functions:

- The `print()` function is used to output information to the console. It is one of the most commonly used functions for displaying results or debugging information.
    ```python
    print("Hello, world!")  # Output: Hello, world!
    ```

- The `input()` function is used to capture input from the user.
    ```python
    name = input("Enter your name: ")
    print("Hello,", name)
    ```

Functions in Python are called by using their name followed by parentheses `()`. Inside the parentheses, you can pass one or more parameters, separated by commas. These parameters are the inputs that the function uses to perform its task. Just like variables, functions are recognizable by their name, and the parentheses indicate that you're *calling*, or *invoking*, the function. For example, in `print("Hello, world!")`, `print` is the function, and `"Hello, world!"` is the parameter being passed to it.

Some functions will *return* a value after performing their task. This returned value can then be assigned to a variable for further use. The `input()` function, for instance, captures the user's input and returns it as a string, which can be stored in a variable.

### 4. **Basic Data Types**

In programming, variables have a data type that defines the kind of information they can store. Data types determine what operations can be applied to a variable and which functions can accept it. Conversely, most functions expect their parameters to have specific data types to work correctly. In Python, the data type of a variable is assigned implicitly and dynamically, meaning you don’t need to declare it explicitly: it’s automatically assigned based on the value the variable holds.

- Here are some of Python's built-in data types:
    - `int`: Integer numbers, e.g., 5, -3, 42
    - `float`: Floating-point numbers, e.g., 3.14, -2.5, 0.99
    - `bool`: Boolean values, either `True` or `False`
    - `str`: Strings, or sequences of characters, e.g., "hello", "Alice", "42". Strings are always recognizable by the surrounding quotes (`"` or `'`).
    - `None`: A special type used to represent the absence of a value or a null value. It is often used to indicate that a variable has no value assigned or that a function does not return anything.

- You can check the type of a variable using the `type()` function:
    ```python
    x = 10
    print(type(x))  # Output: <class 'int'>

    y = 3.14
    print(type(y))  # Output: <class 'float'>

    z = "Hello"
    print(type(z))  # Output: <class 'str'>

    is_active = True
    print(type(is_active))  # Output: <class 'bool'>

    result = None
    print(type(result))  # Output: <class 'NoneType'>
    ```
- You can also convert between types using functions like `int()`, `float()`, and `str()`:
    ```python
    x = "10"
    x = int(x)  # Convert string to integer

    y = 3
    y = str(y)  # Convert integer to string

    z = "3.14"
    z = float(z)  # Convert string to float
    ```

    ⚠️ However, the conversion (also named *casting*) needs to make sense and can sometimes be confusing, especially when working with booleans. For instance, when you cast a non-zero number to a boolean, it will be interpreted as `True`, and when you cast `0` or an empty string `""`, it will be interpreted as `False`:

    ```python
    a = 5
    b = 0
    c = ""
    d = "Hello"

    print(bool(a))  # Output: True (since 5 is non-zero)
    print(bool(b))  # Output: False (since 0 is zero)
    print(bool(c))  # Output: False (since an empty string is considered False)
    print(bool(d))  # Output: True (non-empty string is considered True)
    ```

    This can be tricky at times, so it's important to ensure that the type conversions you make align with your intended behavior in the program.

### 5. **Common Operators**

- **Arithmetic operators:**

    Python supports a wide variety of **arithmetic operators** for numerical calculations:

    - **Addition (`+`)**: Adds two numbers.
    - **Subtraction (`-`)**: Subtracts the second number from the first.
    - **Multiplication (`*`)**: Multiplies two numbers.
    - **Division (`/`)**: Divides the first number by the second, resulting in a float.
    - **Exponentiation (`**`)**: Raises the first number to the power of the second.
    - **Modulus (`%`)**: Returns the remainder of a division.
    - **Floor Division (`//`)**: Divides the first number by the second and returns the largest integer less than or equal to the result.

    Here are some examples of using these operations:

    ```python
    x = 10
    y = 3

    print(x + y)  # Output: 13

    print(x - y)  # Output: 7

    print(x * y)  # Output: 30

    print(x / y)  # Output: 3.333...

    print(x ** y)  # Output: 1000

    print(x % y)  # Output: 1

    print(x // y)  # Output: 3
    ```

- **Compound assignment operators**

    Python also offers **compound assignment operators**, which allow you to perform arithmetic operations and assignments in one step. For example:

    - **Addition Assignment (`+=`)**: Adds the right operand to the left operand and assigns the result to the left operand.
    - **Subtraction Assignment (`-=`)**: Subtracts the right operand from the left operand and assigns the result to the left operand.
    - **Multiplication Assignment (`*=`)**: Multiplies the left operand by the right operand and assigns the result to the left operand.
    - **Division Assignment (`/=`)**: Divides the left operand by the right operand and assigns the result to the left operand.

    Some examples:

    ```python
    x = 10
    y = 3

    x += y  # x = x + y, now x is 13
    print(x)  # Output: 13

    x *= 2  # x = x * 2, now x is 26
    print(x)  # Output: 26
    ```

    Compound assignment operators can make your code more concise and help you avoid repeating the variable name when performing operations.

- **Comparison operators:**

    **Comparison operators** in Python are used to compare two values or variables. These operators return `True` or `False` based on the comparison results, and they are often used in conditional statements and loops.

    Here are the main comparison operators:

    - **Equal to (`==`)**: Returns `True` if the two operands are equal.
    - **Not equal to (`!=`)**: Returns `True` if the two operands are not equal.
    - **Greater than (`>`)**: Returns `True` if the left operand is greater than the right operand.
    - **Less than (`<`)**: Returns `True` if the left operand is less than the right operand.
    - **Greater than or equal to (`>=`)**: Returns `True` if the left operand is greater than or equal to the right operand.
    - **Less than or equal to (`<=`)**: Returns `True` if the left operand is less than or equal to the right operand.

    Examples:

    ```python
    x = 10
    y = 5

    print(x == y)  # Output: False (x is not equal to y)
    print(x != y)  # Output: True (x is not equal to y)
    print(x > y)   # Output: True (x is greater than y)
    print(x < y)   # Output: False (x is not less than y)
    print(x >= y)  # Output: True (x is greater than or equal to y)
    print(x <= y)  # Output: False (x is not less than or equal to y)
    ```

    Comparison operators are essential in decision-making processes, helping you control the flow of your program based on conditions. They are commonly used in `if` statements, loops, and while checking the truth of expressions.

- **Logical operators:**

    Python provides **logical operators** for combining boolean statements:

    - **And (`and`)**: Returns `True` if both conditions are true.
    - **Or (`or`)**: Returns `True` if at least one of the conditions is true.
    - **Not (`not`)**: Reverses the truth value of the condition.

    Examples:

    ```python
    x = 10
    y = 5

    print(x > 5 and y < 10)  # Output: True (both conditions are true)

    print(x > 5 or y > 10)  # Output: True (at least one condition is true)

    print(not(x > 5))  # Output: False (x > 5 is true, but "not" makes it false)
    ```

### 6. **String Manipulation**

Strings in Python are sequences of characters. You can manipulate them in various ways.

- **Indexing**: You can access individual characters in a string by using square brackets (`[]`). Python uses **zero-based indexing**, meaning the first character is at index 0. You can also use **negative indexing**, which starts from the end of the string (with `-1` being the last character).

    ```python
    s = "Python"
    print(s[0])  # Output: P
    print(s[1])  # Output: y
    print(s[-1])  # Output: n (last character)
    print(s[-2])  # Output: o (second to last character)
    ```

- **Slicing**: You can extract a portion of a string using the slicing syntax `s[start:end]`, where `start` is the index of the first character, and `end` is the index of the character just past the last character you want.

    ```python
    s = "Python"
    print(s[1:4])  # Output: yth (from index 1 to 3)
    print(s[-3:-1])  # Output: ho (from third to last character to the second to last character)
    ```

- **String Methods**: Python provides a number of built-in methods to manipulate strings. Some common methods include:

    - `.lower()`: Converts all characters to lowercase.
    - `.upper()`: Converts all characters to uppercase.
    - `.strip()`: Removes whitespace from both ends of the string.
    - `.replace(old, new)`: Replaces occurrences of a substring with a new string.

    ```python
    s = " Hello, World! "

    print(s.lower())  # Output: hello, world!

    print(s.upper())  # Output: HELLO, WORLD!

    print(s.strip())  # Output: Hello, World!

    print(s.replace("Hello", "Hi"))  # Output: Hi, World!
    ```

- **String Formatting**: Python allows you to format strings in a readable way using f-strings, the `.format()` method, or the `%` operator.

    ```python
    name = "Alice"
    age = 30

    # Using f-strings
    print(f"My name is {name} and I am {age} years old.")

    # Using .format() method
    print("My name is {} and I am {} years old.".format(name, age))  

    # Using the `%` operator
    print("My name is %s and I am %d years old." % (name, age))

    # Outputs: My name is Alice and I am 30 years old.
    ```

- **Concatenation and Repetition**: You can concatenate (combine) strings with the `+` operator and repeat them with the `*` operator.

    ```python
    greeting = "Hello"
    name = "Alice"

    # Concatenate
    print(greeting + " " + name)  # Output: Hello Alice

    # Repeat
    print("Hi! " * 3)  # Output: Hi! Hi! Hi! 
    ```

- **Checking Substrings**: You can check if a substring exists in a string using the `in` and `not in` operators.

    ```python
    sentence = "Hello, world!"

    # Check if 'world' is in the sentence
    print("world" in sentence)  # Output: True

    # Check if 'goodbye' is not in the sentence
    print("goodbye" not in sentence)  # Output: True
    ```

- **Special Characters and Escape Sequences**: Strings can contain special characters, which are often represented by escape sequences. An escape sequence starts with a backslash (`\`) and allows you to include characters that are difficult or impossible to type directly, like newline (`\n`), tab (`\t`), or a backslash itself (`\\`).

    ```python
    # Newline
    print("Hello\nWorld!")  # Output: Hello (new line) World!

    # Tab
    print("Hello\tWorld!")  # Output: Hello    World!

    # Backslash
    print("C:\\Program Files\\Python")  # Output: C:\Program Files\Python
    ```
    Additionally, you can use escape sequences to include quotes within strings without ending the string (you can also use different types of quotes for the string and the quotes inside it).
    ```python
    print("She said, \"Hello, World!\"")  # Output: She said, "Hello, World!"
    print('She said, "Hello, World!"')  # Output: She said, "Hello, World!"
    print('It\'s a sunny day!')  # Output: It's a sunny day!
    print("It's a sunny day!")  # Output: It's a sunny day!
    ```

**⚠️ Note:**

In Python, there are two common ways to use functions: **method calls** and **function calls**. Both involve calling functions, but they have different syntaxes and purposes.

- **Method call (`var.function()`)**: This is when you call a function that is **associated with a particular variable or object**. The function is tied to the object and is called using dot notation. The variable (`var`) is the object that the method operates on. For example, strings have built-in methods like `.lower()` or `.upper()`, which can be used to manipulate the string directly.

- **Function call (`function(var)`)**: This is when you call a **standalone function** and pass variables or values to it as parameters. The function is independent of any particular variable or object, and it operates on the arguments you provide.

    ```python
    text = "Hello"
    print(text.lower())  # Output: hello
    ```

    In this case, `lower()` is a method of the `text` string object, and it operates specifically on that object. On the other hand, `print()` is a standalone function and isn't tied to a specific object.

## III - Data Structures

In Python, data structures allow us to store, organize, and manipulate collections of data efficiently. They help in structuring our programs and optimizing operations like searching, sorting, and accessing elements. Python provides several built-in data structures, each suited for different use cases.

### 1. Lists

A **list** is a collection of items that can store multiple values in an ordered sequence. Lists are **mutable**, meaning their contents can be changed after creation.

- **Creating a List**

    Lists are defined using square brackets `[]`, with elements separated by commas.
    ```python
    # Creating a list of numbers
    numbers = [1, 2, 3, 4, 5]

    # Creating a mixed-type list - ⚠️Not advised
    mixed = [1, "hello", 3.5, True]
    ```

- **Accessing Elements**

    Elements in a list can be accessed using **zero-based indexing**:

    ```python
    numbers = [10, 20, 30, 40]

    print(numbers[0])  # First element: 10
    print(numbers[2])  # Third element: 30
    ```

- **Slicing Lists**

    Slicing allows extracting a subset of a list using the `[start:stop:step]` notation:

    ```python
    numbers = [0, 1, 2, 3, 4, 5, 6]

    print(numbers[1:4])   # [1, 2, 3] (from index 1 to 3)
    print(numbers[:3])    # [0, 1, 2] (first three elements)
    print(numbers[3:])    # [3, 4, 5, 6] (from index 3 to the end)
    print(numbers[::2])   # [0, 2, 4, 6] (every second element)
    print(numbers[::-1])  # [6, 5, 4, 3, 2, 1, 0] (reverse the list)
    ```

- **Modifying a List**

    Lists support modification of elements:

    ```python
    numbers[1] = 25  # Changing the second element
    print(numbers)  # [10, 25, 30, 40]
    ```

- **Adding and Removing Elements**

    - **Appending elements** to the end of a list:

        ```python
        numbers.append(50)  # [10, 25, 30, 40, 50]
        ```

    - **Inserting elements** at a specific index:

        ```python
        numbers.insert(2, 15)  # Insert 15 at index 2
        ```

    - **Removing elements**:

        ```python
        numbers.remove(30)  # Removes the first occurrence of 30
        last_item = numbers.pop()  # Removes and returns the last element
        ```

### 2. Tuples

A **tuple** is an immutable sequence of elements, meaning it cannot be modified after creation. Tuples are useful when you want to store a fixed collection of items.

- **Creating a Tuple**

    Tuples use parentheses `()` or can be created without brackets:

    ```python
    coordinates = (10.5, 20.3)
    single_element = (42,)  # Note the comma is necessary for single-element tuples
    ```

- **Accessing Tuple Elements**

    Like lists, elements in a tuple can be accessed via indexing and slicing:

    ```python
    tuple_data = (10, 20, 30, 40, 50)
    print(tuple_data[0])  # Output: 10
    print(tuple_data[1:4])  # Output: (20, 30, 40)
    print(tuple_data[::-1])  # Output: (50, 40, 30, 20, 10)
    ```

**⚠️ Note:**

Python data types can be categorized based on whether they allow modifications after creation:

- **Mutable types**: Can be modified (e.g., lists, dictionaries, sets)
- **Immutable types**: Cannot be modified (e.g., tuples, strings, numbers)

Example:

```python
name = "Alice"
# name[0] = "B"  # This will raise an error because strings are immutable

numbers = [1, 2, 3]
numbers[0] = 10  # Allowed because lists are mutable
```

### 4. Dictionaries

A **dictionary** is a collection of key-value pairs, where each key is unique (values can have duplicates). Dictionaries allow fast lookups and modifications.

- **Creating a Dictionary**

    Dictionaries are created using curly braces `{}`:

    ```python
    person = {
        "name": "Alice",
        "age": 25,
        "city": "New York"
    }
    ```

- **Accessing Values**

    Values are retrieved using keys:

    ```python
    print(person["name"])  # Output: Alice
    ```

- **Adding and Modifying Key-Value Pairs**

    ```python
    person["age"] = 26  # Modify existing key
    person["job"] = "Engineer"  # Add a new key-value pair
    ```

- **Removing Elements**

    ```python
    del person["city"]  # Removes the key-value pair with key "city"
    age = person.pop("age")  # Removes and returns the value for "age"
    ```

### 5. Sets

A **set** is an *unordered* collection of unique elements. Sets are useful for eliminating duplicates and performing set operations.

- **Creating a Set**

    ```python
    fruits = {"apple", "banana", "cherry"}
    ```

- **Adding and Removing Elements**

    ```python
    fruits.add("orange")  # Add an element
    fruits.remove("banana")  # Remove an element
    ```

- **Set Operations**

    ```python
    a = {1, 2, 3, 4}
    b = {3, 4, 5, 6}

    print(a | b)  # Union: {1, 2, 3, 4, 5, 6}
    print(a & b)  # Intersection: {3, 4}
    print(a - b)  # Difference: {1, 2}
    ```
